cluster - node -pod 
کلاستر مجموعه ای از نود ها است و همچنین نود ها مجموعه ای از پاد ها هستند 
نود را میتوان همان سرور ها در نظر گفت
هر نود یک آی پی دارد
و نود های مختلف از طریق آی پی میتواندد با هم در ارتباط باشند
پاد کوچکترین جز می باشد که کوبرنیتز میتواند آن را مدیریت کند
پاد مجموعه ای از کانتینر ها است
به صورت کلی کوبرنیتز کانتینرها را مدیریت نمی کند بله پاد ها را مدیریت می کند
kubectl action resoure شکل کلی دستور
kubectl run hellword --image=imagename  ایجاد پاد
kubectl get pods     گرفتن تمام پادها
kubectl describe pod helloword  اطلاعات مهم مربوط به پاد را نمایش میدهد
kubectl get pod helloword -o json تمام اطلاعات مربوط به پا در در خروجی جی سان نمایش بده
kubectl port-forward pod/helloword  8080:80 برای تنظیم پورت به پاد مورد نظر برای مشاهده در مروگر 
start "" /B kubectl port-forward pod/firstpod1 8080:3000  برای تنظیم پورت به پاد مورد نظر برای مشاهده در مرورگر و همچنین در پس زمینه اجرا مشود و کامنت پرامت قفل نمیشود

kubctl delete pod helloword برای حذف پاد مورد نظر
kubectl exec deploy/cachexample -c cach1 --killall5  برای از بین بردن کانتینر استفاده میشود و حذف محسوب نمیشود

kubectl get pod p1 hostpath -o yaml  //نمایش فایل یملی که این پاد را ساخته
kubectl get pv //گرقتن تمام ولیوم ها 

kubectl apply -f HelloWorl.yaml  برای اجرای یک فایل یمل
kubectl apply -f newfolder1/  برای اجرای تمام فایل های یمل در مسیر نیوفولدریک

kubectl delete -f HelloWorl.yaml  برای حذف اجرای یک فایل یمل
kubectl delete -f newfolder1/  برای حذف اجرای تمام فایل های یمل در مسیر نیوفولدریک


kubectl get rs   برای اینکه متوجه شویم داخل هر دپلویمنت چند تا پاد وجود دارد

kubectl top pod   برای اینکه متوجه شویم هر پاد چقدر سی پیو و حافظه مصرف میکند

kubectl get jobs   نمایش تمام جاب های تعریف شده
kubectl logs jobs/jobename   نمایش لاگ های مربوط به جاب مورد نظر

kubectl get cronjobs  نمایش تمام کارهای که قرارهست در بازه زمانی مشخص اجرا شود

rollout :وقتی که یک نسخه روی از برنامه را روی موبرنیتیز داریم و میخواهیم ورژن جدید برنامه را قرار بدهیم ابتدا چند تا پاد با ورژن جدید آپدیت میشود و یکی از پاد ها با همان نسخه قدیمی کار میکند که در نهایت همان یک پاد نسخه قدیمی هم آپدیت می شود دلیل اینکه 
همه پاد ها یکباره آپدیت نمیشود به خاطر این است که برنامه حتی یک ثانیه هم از کار نیافتد که این وظیه رول اوت می باشد
دونه به دونه پادها را با نسخه جدید جایگزین میکند

kubectl rollout status deploy/pod1   بررسی رول اوت و نمایش مراحل آن 
kubectl rollout undo deploy/pod1 برگردان ایمیج پادها به همان ورژن قبلی 
وقتی که یک پاد با ورژن جدید آپدیت میشود ممکن است شما منصرف شوید و نیاز باشد که دو باره همان ورژن قبلی را فعال کنید


//******************************************************************************************************************************
ایجاد یک فایل یمل که داخل آن یم پاد تعریف کرده ایم

برای ایجاد یک پاد بر روی فایل یمل

حتما باید فاصله بعد از دو نقطه باشد
مثل 
apiVersion: V1




apiVersion:V1 ورژن کوبرنیتیز که روی سیستم داریم استفاده میکنیم

kind:pod   ریسورس یا منبع را مشخص میکنیم

metadata: توصیف داده های اضافی
  name:Hello-kube   نام پاد را مشخص میکنیم

spec:  اطلاعات خاص را مینویسم
  containers:  تعریف کانتینرها
    - name:web1  یک نام برای کانتینر قرار میدهیم
      image:node1  نام ایمجی که مد نظر داریم
      imagePullPolicy: Never وقتی برابر با خط زیر باشد ابتدا روی سیستم خودمان دنبال ایمیج میگرد ،در صورتی که وجود نداشته باشد دانلود میکند

//******************************************************************************************************************************



kubectl apply -f podfile.yaml برای اجرای فایل یمل در کوبرنیتیز

kubectl delete -f podfile.yaml  برای برگرداندن یا حذف چیزی های که قبلا از طریق این فایل اجرا شده یا ایجاد شده است


//********************************************************************************************************************************
وظیفه deployment در کوبرنیتیز
مسولیت چند تا پاد را بعهده دارد
ممکنه یک پاد باشد یا چند تا پاد
در صورتی که یک پاد حذف یا خراب شود و نتواند سرویس دهد سریعا یک پاد توسط دیپلویمنت جایگزین میشود




kubectl create deploy hello-kube --image=node1    برای ایجاد یک دپلوی منت که داخل آن یک پاد وجود دارد


kubectl get deploy hello-kube -o json تمام اطلاعات مربوط به دپلوی منت را نمایش بده

kubectl get deploy hello-kube -o jsonpath="{.spec.template.metadata.labels}" تمام اطلاعات مربطو به دپلوی منت بصورت جی سان باشد اما فقط اطلاعاتی که مشخص کرده ام 
kubectl get pods -l app=example -o jsonpath='{.spec.initContainers[*].name}'   برای پیدا کردن نام کانتینر تمام پاد ها


kubectl get pods -l app=example -o custom-columns='NAME:.metadata.name,STATUS:.status.phase,NODE:.spec.nodeName,CONTAINERS:.spec.containers[*].name,INIT_CONTAINERS:.spec.initContainers[*].name'



kubectl get pods -l app=hello-kube   تمام پاد های که لیبیل مورد نظر را دارند را بازیابی کنیم

kubectl port-forward deployment/Hellokube --8080:80   برای ارائه پورت به دپلوی برای نمایش یک پاد در مرورگر
kubectl port-forward deployment/mongo 28015:27017

kubectl delete deploy hello-kube   برای حذف دپلوی مورد نظر - در صورتی که حذف انجام شود تمام پاد های که زیر نظر آن دیپلوی هستند حذف میشود

//*********************************************************************************************************************************

تعریف دپلوی منت در فایل 

apiVersion:apps/v1    
kind:Deployment   نوع منبع یا ریسورس را مشخص میکنیم

metadata:
  name:Hello-Word    نام دپلوی منت را مشخص میکنیم

spec:در این قسمت باید مشخص کنیم که دپلویمنت چه پاد های را باید مدیریت کند
  selector:
    matchlabels:
      app:Hello-Word   دپلویمنت میتواند پادهای که لبیل با کلید و مقدار مشخص روبه رو را دارند را میتواند مدیریت کند


template: پادهای که همراه با این دپلویمنت میخواهیم ایجاد کنیم
  metadata:
    labels:
      app:Hello-Word  پاد ها با لیبیل رو برور ایجاد شود
  spec:       مشخصات پاد را مشخص میکنیم 
    containers:
      - name:web1
        images:node1/sql
        ports:
          - containerport:5000 //در این قسمت باید پورت داخل داکر فایل  را اینجا وارد کنیم


//****************************************************************************************************************************************

برای اتصال به یک کانتینر در یک پاد به چه صورت عمل میکنیم

kubectl exec deploy/hello-word -c web1 -it -- sh    ابتدا از طریق نام دپلویمنت وارد شو سپس نام کانتینر مشخص شود سپس یک تعامل برقرار شود و سپس وارد مسیر شل شود
cat /app/a.txt هنگامی که وارد محیط کانتینر میشویم و میخواهیم محتوای یک فایل را مشاهده کنیم 
hostname -i   هنگامی که از طریق دستور بالا وارد شل بشویم میتوانیم از طریق همین دستور آی پی پاد را بدست بیاوریم
داحل هر پاد چند تا کانتینر میتواند باشد که آدرس همان پاد را میگیرد با پورت های متفاوت

//****************************************************************************************************************************************

مشاهده لاگ های یک کانتینر از طریق دپلوی منت
-c اشاره به کانتینر دارد

kubectl logs deploy/hello-word -c web1 

//**************************************************************************************************************************************
برای مشاهده آی پی پاد  
kubectl get pod -l app=hello-kube1  -o wide
kubectl get pod -l app=example -o wide
//*************************************************************************************************************************************
پاد ها از طریق آی پی می توانند با هم ر ارتباط باشند
اما چون پاد ها ممکن هست بعد از مدتی حذف شود و پاد دیگری جای آن را بگیرد بنابراین آی پی آن هم تغییر میکند 
بهترین کار این است که یک سرویس تعریف کنیم که مدیریت شبکه ای پاد ها را مدیریت کند 
و با استفاده از نام سرویس میتوانیم پاد ها را مدیریت کنیم زیر نام سرویس دیگر مثل آی پی تغییر نمی کند و یک سرویس میتواند چندین پاد را مدیریت کند


//*************************************************************************************************************************************
برای اینکه بتوانیم از طریق دستورات صفحه اچتیمل یک صفحه را ببینیم

curl google.com
یا
curl 216.239.38.120

//*************************************************************************************************************************************

یک سرویس داریم و برای فعال کردن آن و غیر فعال کردن آن کافی است تعداد پاد های آن صفر یا بیش از صفر باشد
kubectl scale deployment/<deployment-name> --replicas=0 -n <namespace>




 برای اینکه بتوانیم زیر ساخت شبکه پاد های را مدیریت کنیم باید از سرویس ها استفاده کنیم
یا به عبارتی برای مدیریت و هماهنگی بین پاد نیاز به سرویس ها داریم مثل
ClusterIP

برای فراهم کردن یک آدرس ثابت که بتوانیم از طریق مرورگر به آن دسترسی داشته باشیم از سرویس استفاده میکنیم
سرویس داخلی از نوع  کلاستر آی پی می باشد
و سرویس خارجی از نوع لود بالانسر می باشد


برای ایجاد یک سرویس بصورت زیر عمل میکنیم

apiVersion:V1
kind:Service
metadata:
  name:hello-kube1-svc

spec:یکسری مشخصادت باید توصیف کنیم
  selector:
    app=Hello-kube-1  در این قسمت وظیفه سرویس این است که تمام پاد های که لیبیل رو به رو را دارند  را مدیریت میکند
  ports:
    - port:8080  این سرویسی که ایجاد کرده ایم روی چه پورتی گوش یا به عبارتی در مرورگر با چه پورتی قابل مشاهده باشد 
      targetport:7586    موقعی که یک پاد را ایجاد میکنیم و درون ان یک کانتینر تعریف میکنیم به آن کانتینر یک پورت اختصاص می دهیم آن پورت اختصاص داده شده را اینجا مینویسیم
type:ClusterID    در صورتی که نوشته نشده باشد کلاستر آی دی در نظر گرفته میشود و وقتی به این صورت تعریف شود یعنی از بیرون امکان دسترسی به این پاد وجود ندارد و بصورت داخل شبکه ای امکان برقراری ارتباط وجود دارد
type:loadBalancer     وقتی به این صورت تعریف شود یعنی از بیرون امکان دسترسی به این پاد وجود دارد  و میتوان خارج از شبکه داخلی به آن دسترسی داشت


kubectl port-forward svc/Hello-svc 8080:80   برای تنظیم پورت روی سرویس ها
//************************************************************************************************************************
برای اینکه بتوانیم از داخل یک سرویس لودبالانسر یک سرویس داخل کلاسترآی پی را صدا بزنیم فقط کافیست که نام سرویس کلاسترآی پی را در قسمت زیر وارد کنیم

Appsetting.json فایل 

 "UrlApi": {



    //"ApiRandom": "http://localhost:5136/api/",
    "ApiRandom": "http://localhost:80/api/", //چون خود همین پروژه را صدا میزند درون داکر باید با پورت 80 باشد نه با پورتی که خود این پروژه روی داکر هست
    "ApiRandomInternal": "http://randomapi-internal-service:8044/api/"

  }

 randomapi-internal-service  نام سرویس کلاستر آی پی هست
 8044  پورت سرویس کلاستر آی پی نام سرویس بالا



 private readonly HttpClient _client;
 private readonly IConfiguration _configuration;
 public HomeController(HttpClient client, IConfiguration configuration)
        {
            _client = client;
            _configuration = configuration;
        }
var urlApiRandom = _configuration.GetValue<string>("UrlApi:ApiRandomInternal");
                _client.BaseAddress = new Uri(urlApiRandom);
                StringContent httpContent = new StringContent("", System.Text.Encoding.UTF8, "application/json");
                var result = await _client.PostAsync("Home/Test1", httpContent);
                var guid = result.Content.ReadFromJsonAsync<string>().Result;


//*************************************************************************************************************************************
svc به کلمه سرویس اشاره می کند

kubectl get svc   hello-kube1-svc12      برای مشاهده اطلاعات سرویس مورد نظر


//**************************************************************************************************************************************  
یک سرویس دیگر داریم بنام
Nodeport
دلایل استفاده از NodePort:
 میتوانیم خارج از شبکه داخلی یعنی بیرون سازمان به سرویس پاد مورد نظر دسترسی داشته باشیم
یک پورت مشخص (معمولاً بین 30000 تا 32767) را روی تمامی نودهای کلاستر باز می‌کند 
که بیشتر زمان توسعه نرم افزار کاربرد دارد

مثال:

apiVersion: v1
kind: Service
metadata:
  name: my-web-service
spec:
  type: NodePort
  selector:
    app: my-web-app
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
      nodePort: 30001

http://<node-ip>:30001  //قابل دسترس هست
http://localhost:30001

//*************************************************************************************************************************************
سرویس ExternalName
فکر کنید یک پاد دارید که یک وب سرویس روی آن بالا می آید اما دیتابیس آن روی یک سیستم دیگر است یا به عبارتی درون کوبرنیتیز نیست 
برای اتصال به آن نیاز به سرویس اکسترنال نیم داریم
مثال -
یه برنامه سرویس دهنده روی یک پاد داریم حال میخواهیم به دیتابیس سیسم لوکال که روی سیستم خودمان هست وصل شود بنابراین از اکسترنال نیم استفاده میکنیم

apiVersion: v1
kind: Service
metadata:
  name: external-db-service
  namespace: default
spec:
  type: ExternalName
  externalName: my-external-db.example.com //آدرس سیستمی که روی لوکوال یا خارج از کوبرنیتز می باشد
  ports:
    - port: 5432


//***********************************************************************************************************************************
برای اینکه بتوانیم برای کانتینر خودمان یک 
volume
تعریف کنیم ابتدا باید دستور زیر را اجرا کنیم

minikube mount F:\AppDockerVoulme:/mnt/appdata

//*********************************************************************************************************************************

apiVersion: apps/v1
kind: Deployment
metadata:
  name: example-deployment
spec:
  replicas: 3
  selector:
    matchLabels:
      app: example
  template:
    metadata:
      labels:
        app: example
    spec:
      containers:
        - name: api1 
          image: productsapi    
          imagePullPolicy: Never 
          ports:
            - containerPort: 8080
          volumeMounts:
            - name: app-data
              mountPath: /app/data   # مسیر داخل کانتینر
      volumes:
        - name: app-data
          hostPath:
            path: /mnt/appdata       # مسیر داخل Node (پس از mount شدن)
            type: Directory


//****************************************************************************************************************
برای اینکه بتوانیم یک پاد که داخلی هست بتواند با یک برنامه خارج از کوبرنیتیز ارتباط برقرار کند
از سرویس زیر استفاده میکنیم
HeadLess

مستقیماً با پادها از طریق آی پی ارتباط برقرار میکنیم
HeadLess هنگامی که سرویس بیرونی نام نداشته باشد و بخواهیم از طریق آی پی به آن وصل بشویم استفاده میکنیم 
ExternalName هنگامی از این سرویس استفاده میکنیم که میتوانیم از نام آن سرویس استفاده کنیم 

وقتی می‌خواهید مستقیماً با هر پاد صحبت کنید نیاز هست از این نوع سرویس استفاده کنیم زیرا مستقیما به آی پی پاد وصل میشویم
اما اگر پاد از بین برود ارتباط قطع میشود پس بهتر است از طریق نام سرویس وصل بشویم

apiVersion: v1
kind: Service
metadata:
  name: my-headless-service
spec:
  clusterIP: None  //با استفاده از این ویژگی متوجه میشویم که سرویس از نوع هدلس می باشد و این بدان معناست که به پاد ها یک آی پی واقعی بدهد تا بتوانیم مستقیما به آن پاد وصل بشویم
  ports:
    - port: 80  //درگاهی که سرویس از طریق آن به خارج از پاد قابل دسترسی است
      targetPort: 9376  //   پورت داخلی پاد یا همان پورت کانتینر که هنگام دپلوی منت تعریف میکنیم
  selector:
    app: my-app  //این بخش مشخص می‌کند که این سرویس روی چه پادهایی اعمال می‌شود


//*************************************************************************************************************
بخش namespace
کلمه ان به نیم اسپیس اشاره میکند 
(-n == namespace)
kubectl get namespaces    //برای مشاهده تمام نیم اسپیس ها
kubectl get pods -n kubenamespace //تمام پاد های که در نیم اسپیس مورد نظر هست را پیدا کن
kubectl create namespace prodname //ایجاد یک نیم اسپیس
kubectl get svc -n kubenamespace //تمام سرویس های  که در نیم اسپیس مورد نظر هست را پیدا کن
kubectl apply -f a.yaml -n prod1 //سرویس مورد نظر را ببر به نیم اسپیس مورد نظر

//****************************************************************************************************************
برای تعریف متغییر های سراسری داخل کانتینر بصورت زیر عمل میکنیم
Enviroment Variable متغییرهای محیطی

apiVersion: apps/v1
kind: Deployment
metadata:
  name: randomapi-external-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: randomapi-external
  template:
    metadata:
      labels:
        app: randomapi-external
    spec:
      containers:
        - name: random-external-container 
          image: apiexternal1   
          imagePullPolicy: Never 
          ports:
            - containerPort: 80
          env://برای تعریف متعیرهای محیطی
            - name:  StatuesID  //نام متغییر محیطی
              value:  "beta"//مقدار متغیر محیطی




دو تا متغییر محیطی تعریف کردن 

apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  containers:
  - name: my-container
    image: my-image
    env://برای تعریف متعیرهای محیطی
    - name: ENV_VAR_NAME  //نام متغییر محیطی
      value: "value"   //مقدار متغیر محیطی
    - name: ANOTHER_VAR   //نام متغییر محیطی
      value: "another_value"  //مقدار متغیر محیطی


//************************************************************************************************************
روش تعریف متعییر های محیطی به روش 
configmap
به این صورت است که داخل یک فایل با پسوند زیر نام متغییر و مقدار متغییر را لیست میکنیم
A1.env  نام فایل

StatuesID=120
Person=naser

برای مشاهده در داخل کانتیرها فقط کافیست دستور زیر را وارد کنید تا مقدار آن را نمایش بدهد
printenv  StatuesID
120 خروجی



kubectl create configmap random-api-config --from-env-file=configfolder/config.env  //ایجاد یک کانفیک متعیر محیطی که یک نام دارد و در انتها آدرس مسیر فایل را قرارداده ایم

kubectl describe cm/random-api-config  اطلاعات فایل کانفیگ را میدهد



apiVersion: apps/v1
kind: Deployment
metadata:
  name: randomapi-external-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: randomapi-external
  template:
    metadata:
      labels:
        app: randomapi-external
    spec:
      containers:
        - name: random-external-container 
          image: apiexternal1   
          imagePullPolicy: Never 
          ports:
            - containerPort: 80
          env://برای تعریف متعیرهای محیطی
            - name:  StatuesID  //نام متغییر محیطی
              value:  "beta"//مقدار متغیر محیطی

          envFrom://برای تعریف متعیر محیطی از طریق کانفیگ مپ
            - configMapRef:
                name:random-api-config //نام کانفیگ مپ را ست میکنیم


//**********************************************************************************************************************
configmap
در صورتی که فایل کانفیگ مپ بصورت یک فایل از نوع تکست یا جی سان باشد به صورت زیر باید کانفیگ ایجاد کنیم

kubectl create configmap redisA1 --from-file=configmap1/redis.conf  //برای ایجاد یک کانفیگ که در انتها مسیر فایل مورد نظر درج شده است
kubectl delete cm redisA1 برای حذف کانفیگ مورد نظر


برای اینکه بتوانیم دستوراتی که در محیط داس مینویسم بتوانیم فایل یمل آن را ایجاد کنیم باید در انتهای دستور کد زیر را بنویسیم

kubectl delete cm redisA1 --dry-run=client -o yaml   //مشابه همین دستور را در قالب فایل یمل ارائه میدهد


شکل کلی فایل کانفیک در فایل یمل

apiVersion: v1
kind: ConfigMap
metadata:  
  name: game-config
  namespace: default
   
data:
  game.properties: |
    enemies=aliens
    lives=3
    enemies.cheat=true
    enemies.cheat.level=noGoodRotten
    secret.code.passphrase=UUDDLRLRBABAS
    secret.code.allowed=true
    secret.code.lives=30    
  ui.properties: |
    color.good=purple
    color.bad=yellow
    allow.textmode=true
    how.nice.to.look=fairlyNice  





//**********************************************************************************************************************
برای ایجاد امنیت در داده ها روی کوبرنیتیز

یک منبع از نوع زیر ایجاد میکنیم
secure




//******************************************************************************************************************
Volume

انواع آن:

emptyDir:{} وابسته به پاد می باشد در صورتیکه پاد حذف شود این ولیوم هم حذف میشود کارایی این نوع ولیوم بیشتر برای کش کردن اطلاعات موقت است


hostpath:   //وابسته به پاد نمی باشد و یک سطح بالا تر می باشد که بهآن سطح نود گفته میشود و با جذف نود از بین می رود
  path:f/folder1 //مسیر ذخیره سازی
  type:DirectoryOrCreate //اگر مسیر بالا وجود ندارد آن را ایجاد کن



PersistentVolumeClaim :یک نوع والیوم هست که یک درخواست میدهد که چقدر فضای ذخیره سازی نیاز داریم
  claimName:P1_Pvc


apiVerion:v1
kind:PersistentVolumeClaim
metadata:
  name:P1_Pvc
spec:
  accessModes:
    - ReadWriteOnce --فقط یک پاد بتواند روی این فضا بخواند و بنویسد
  resources:
    request:
      storage:1Gi   درخواست یک گیگ فضای ذخیره سازی




kubectl get pvc //برای مشاهده تمام PersistentVolumeClaim
kubectl get storageClass  //برای لیست کردن تما استوریج کلس ها



تفاوت Directory با DirectoryCreate در چه چیزی هست
در دایرکت باید حتما مسیر وجود داشته باشد
در دایرکت کریتور اگر مسیر وجود نداشته باشد آن مسیر ایجاد میشود


storageClass بصورت داینامیک میزان خواسته کاربر از فضای ذخیره سازی را ایجاد میکند



apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv-randomapi-external
spec:
  capacity:
    storage: 1Gi
  volumeMode: Filesystem
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain
  hostPath:
    path: /run/desktop/mnt/host/f/volumes-randomapi-external
    type: DirectoryOrCreate


//*****************************************************************
 
apiVersion: v1
kind: PersistentVolume
metadata:
  name: pv-randomapi-external
spec:
  capacity:
    storage: 1Gi
  volumeMode: Filesystem
  accessModes:
    - ReadWriteOnce
  persistentVolumeReclaimPolicy: Retain  #این ولیوم با حذف پاد از بین نمی رود
  hostPath:
    path: /run/desktop/mnt/host/f/volumes-randomapi-external
    type: DirectoryOrCreate

--- #برای اینکه بتوانیم چند تا محتوای فایل یمل را کنار همدیگر قرار بدهیم

apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: pvc-randomapi-external
spec:
  accessModes:
    - ReadWriteOnce
  resources:
    requests:
      storage: 1Gi
  volumeName: pv-randomapi-external

--- #برای اینکه بتوانیم چند تا محتوای فایل یمل را کنار همدیگر قرار بدهیم

apiVersion: apps/v1
kind: Deployment
metadata:
  name: randomapi-external-deployment
spec:
  replicas: 1
  selector:
    matchLabels:
      app: randomapi-external
  template:
    metadata:
      labels:
        app: randomapi-external
    spec:
      containers:
        - name: random-external-container 
          image: apiexternal1   
          imagePullPolicy: Never 
          ports:
            - containerPort: 80
          volumeMounts:
            - name: volumes-randomapi-external
              mountPath: /app
           
      volumes:
        - name: volumes-randomapi-external
          persistentVolumeClaim:
            claimName: pvc-randomapi-external


//************************************************************************************************
برای تخصیص منابع به هر پاد به چه صورت عمل میکنیم

apiVersion: apps/v1
kind: Deployment
metadata:
  name: randomapi-external-deployment
spec:
  replicas: 1 #برای اینکه مشخص کنیم چند تا پاد داخل این دپلوی منت داشته باشیم
  selector:
    matchLabels:
      app: randomapi-external
  template:
    metadata:
      labels:
        app: randomapi-external
    spec:
      containers:
        - name: random-external-container 
          image: apiexternal1   
          imagePullPolicy: Never #برای اینکه بتوانیم از ایمیج های خود داکر سیستم خودمان استفاده کنیم
          ports:
            - containerPort: 80
          resources:   #در این قسمت منابع را مشخص میکنیم
            requests:  #این بخش حداقل منابع مورد نیاز کانتینر را مشخص میکند.
              memory: "64Mi"
              cpu: "250m"
            limits:  #این بخش حداکثر منابعی که کانتینر میتواند استفاده کند را مشخص میکند
              memory: "128Mi"
              cpu: "500m" 


---  #برای اینکه بتوانیم میحتوای دو تا فایل یمل را داخل یک فایل یمل قرار بدهیم

apiVersion: v1
kind: Service
metadata:
  name: randomapi-external-service  # Replace with your service name
spec:
  selector:
    app: randomapi-external # در این قسمت مشخص میکنیم که چه پادهای با چه لبیلی را مدیریت کند
  ports:
    - port: 8045          # Service port
      targetPort: 80  # همان پورت کانینر که داخل پاد تعریف میکنیم 
  type: LoadBalancer
 



//***************************************************************************************************************************
 
 برای ایجاد چند تا کانتینر درون یک پاد 

apiVersion: apps/v1
kind: Deployment
metadata:
  name: randomapi-external-deployment
spec:
  replicas: 1 #برای اینکه مشخص کنیم چند تا پاد داخل این دپلوی منت داشته باشیم
  selector:
    matchLabels:
      app: randomapi-external
  template:
    metadata:
      labels:
        app: randomapi-external
    spec:
      containers:
        - name: random-external-container 
          image: apiexternal1   
          imagePullPolicy: Never #برای اینکه بتوانیم از ایمیج های خود داکر سیستم خودمان استفاده کنیم
          ports:
            - containerPort: 80
          resources:   #در این قسمت منابع را مشخص میکنیم
            requests:  #این بخش حداقل منابع مورد نیاز کانتینر را مشخص میکند.
              memory: "64Mi"
              cpu: "250m"
            limits:  #این بخش حداکثر منابعی که کانتینر میتواند استفاده کند را مشخص میکند
              memory: "128Mi"
              cpu: "500m" 

        - name: random-external-container2 
          image: apiexternal2   
          imagePullPolicy: Never #برای اینکه بتوانیم از ایمیج های خود داکر سیستم خودمان استفاده کنیم
          ports:
            - containerPort: 81


---  #برای اینکه بتوانیم میحتوای دو تا فایل یمل را داخل یک فایل یمل قرار بدهیم

apiVersion: v1
kind: Service
metadata:
  name: randomapi-external-service  # Replace with your service name
spec:
  selector:
    app: randomapi-external # در این قسمت مشخص میکنیم که چه پادهای با چه لبیلی را مدیریت کند
  ports:
    - port: 8045          # Service port
      targetPort: 80  # همان پورت کانینر که داخل پاد تعریف میکنیم 
  type: LoadBalancer


---  #برای اینکه بتوانیم میحتوای دو تا فایل یمل را داخل یک فایل یمل قرار بدهیم

apiVersion: v1
kind: Service
metadata:
  name: randomapi-external-service1  # Replace with your service name
spec:
  selector:
    app: randomapi-external # در این قسمت مشخص میکنیم که چه پادهای با چه لبیلی را مدیریت کند
  ports:
    - port: 8046          # Service port
      targetPort: 81  # همان پورت کانینر که داخل پاد تعریف میکنیم 
  type: LoadBalancer
 
 
//**************************************************************************************************
تفاوت در ایجاد کانتینر های زیر در چه چیزی هست
initcontainers:ابتدا این قسمت اجرا میشود تا فایل های اولیه را برای کانتینر های دیگر آماده کند
containers:


apiVersion: apps/v1
kind: Deployment
metadata:
  name: webapp-with-init
spec:
  replicas: 2
  selector:
    matchLabels:
      app: webapp
  template:
    metadata:
      labels:
        app: webapp
    spec:
      # تعریف InitContainerها (مرحله آماده‌سازی)
      initContainers: #اول این قسمت اجرا میشود
      - name: download-assets
        image: busybox:latest
        command: ['sh', '-c', 'wget https://example.com/config.tar.gz -O /assets/config.tar.gz && tar -xzf /assets/config.tar.gz -C /assets']
        volumeMounts:
        - name: app-data
          mountPath: "/assets"
      
      # تعریف Container اصلی
      containers: # بعد از اجرای قسمت اول این قسمت اجرا میشود
      - name: webapp
        image: nginx:alpine
        ports:
        - containerPort: 80
        volumeMounts:
        - name: app-data
          mountPath: "/usr/share/nginx/html"
          readOnly: true
        resources:
          requests:
            cpu: "100m"
            memory: "128Mi"
          limits:
            cpu: "200m"
            memory: "256Mi"
      
      # تعریف Volume مشترک
      volumes:
      - name: app-data
        emptyDir: {}


//*********************************************************************************************************
برای برنامه های پویا مثل دیتابیس از چه سرویسی استفاده میکنیم
هر برنامه‌ای که به ذخیره‌سازی پایدار و شناسه‌های ثابت نیاز دارد.


StatefulSet

برای ایجاد پوشه و سطح دسترسی آزاد به آن پوشه

sudo mkdir -p /f/mysql-data
sudo chmod 777 /f/mysql-data  # یا مالک مناسب را تنظیم کنید (مثلاً UID/GID کاربر کانتینر)



mkdir "F:\mysql-data" //ایجاد مسیر
icacls "F:\mysql-data" /grant "Everyone:(OI)(CI)F"  //مجوز دسترسی

icacls "F:\sql1404test" /grant "Everyone:(OI)(CI)F"

F:\sql1404test


[Environment]::SetEnvironmentVariable("DOCKER_SHARED_DRIVES", "F:", "Machine")


//****************************************************************************************************************
برای بررسی و وضعیت سلامت کانتینر ها داخل پاد از چه ویژگی های استفاده میکنیم

readiness  بررسی میکند که آیا کانتینر می تواند ترافیک دریافت کند 
liveness بررسی میکند که آیا کانتینر در حالت اجرا  هست



//یک نمونه  
apiVersion: v1
kind: Pod
metadata:
  labels:
    test: liveness
  name: liveness-exec
spec:
  containers:
  - name: liveness
    image: registry.k8s.io/busybox:1.27.2
    args:
    - /bin/sh
    - -c
    - touch /tmp/healthy; sleep 30; rm -f /tmp/healthy; sleep 600
    livenessProbe://این قسمت مربوط لایونس و دستورات می باشد
      exec:
        command://قسمت دستوز
        - cat
        - /tmp/healthy
      initialDelaySeconds: 5  //بعد از 5 ثانیه دستور بالا  اجرا شود تا ابتدا کانتینر بالا امده باشد
      periodSeconds: 5  //هر 5 ثانیه یکبار قسمت دستور را اجرا کن
      failurethreshold: 3 //اجازه بده 3 بار تلاش کنه که هر 5 ثانیه یکبار دستورات را اجرا کند در صورتی که جواب نگیرد پاد جدیدی جایگزین میشود
   
    
    readinessProbe://این قسمت مربوط ریدنس و دستورات می باشد
      exec:
        command://قسمت دستوز
        - cat
        - /tmp/healthy
      initialDelaySeconds: 5  //بعد از 5 ثانیه دستور بالا  اجرا شود تا ابتدا کانتینر بالا امده باشد
      periodSeconds: 5  //هر 5 ثانیه یکبار قسمت دستور را اجرا کن
      failurethreshold: 3 //اجازه بده 3 بار تلاش کنه که هر 5 ثانیه یکبار دستورات را اجرا کند در صورتی که جواب نگیرد پاد جدیدی جایگزین میشود






apiVersion: v1
kind: Pod
metadata:
  name: goproxy
  labels:
    app: goproxy
spec:
  containers:
  - name: goproxy
    image: registry.k8s.io/goproxy:0.1
    ports:
    - containerPort: 8080
    readinessProbe:
      tcpSocket:
        port: 8080
      initialDelaySeconds: 15
      periodSeconds: 10
    livenessProbe:
      tcpSocket:
        port: 8080
      initialDelaySeconds: 15
      periodSeconds: 10



//*******************************************************************************************

jobs
برای اینکه یک پاد یکبار اجرا شود و خاتمه پیدا کند از جاب ها استفاده میکینم  



apiVersion: batch/v1
kind: Job
metadata:
  name: pi
spec:
  template:
    spec:
      containers:
      - name: pi
        image: perl:5.34.0
        command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]
      restartPolicy: Never  //در صورتی که خطای به وجود بیاید دیگر اجرا نمیشود یا به عبارتی ریستارت نمیشود یا به عبارتی اگر کانتینر کرش کند یا کامل نشود، ریستارت نشود
  backoffLimit: 4  //در صورت شکست جاب - حداکثر تعداد تلاش مجدد برای اجرای جاب






apiVersion: batch/v1
kind: Job
metadata:
  name: pi
spec:
  template:
    spec:
      containers:
      - name: pi
        image: perl:5.34.0
        command: ["perl",  "-Mbignum=bpi", "-wle", "print bpi(2000)"]
      restartPolicy: OnFailure //در صورت خطا دوباره اجرا میشود و ریستارت میشود
  backoffLimit: 4  //در صورت شکست جاب - حداکثر تعداد تلاش مجدد برای اجرای جاب



//****************************************************************************************************
برای اینکه بتوانیم در بازه زمانی متفاوت یک کار را انجام بدهیم از چه سرویسی استفاده میکنم
CronJob



apiVersion: batch/v1
kind: CronJob
metadata:
  name: hello
spec:
  schedule: "* * * * *"  //در این زمان و ساعت این کانتینر اجرا شود مثل جاب های داخل اس کیو ال که در زمان مشخصی انجام میشود
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: hello
            image: busybox:1.28
            imagePullPolicy: IfNotPresent
            command:
            - /bin/sh
            - -c
            - date; echo Hello from the Kubernetes cluster
          restartPolicy: OnFailure



//******************************************************************************************************

استراتژی blue/green 
در این استراتزی یک سرویس تعریف میکنیم با یکسری پاد که   به آن آبی میگویم و در دسترس هست و ترافیک شبکه را دریافت میکند
حالا یک استراتژی تعریف میکنیم که چند تا پاد را مدیریت میکند که مثلا به آن سبز میگویم 
حالا اگر بخواهیم برنامه را آپدیت کنیم فقط کافیست سرویسی که پادهای آبی رنگ را مدیریت میکند از این به بعد پاد های سبز رنگ را مدیریت کند
و با این روش برنامه آپدیت میشود بدون اینکه برنامه لحظه ای متوقف شود

//********************************************************************************************************
helm
برای نصب هلم بصورت زیر عمل میکنیم
برای مدیریت اپلیکشن های به کار می رود
نحوه استفاده از هلم چارت های آماده:
helm install nginxapp1 bitnami/ngnix	برای نصب یک اسم اختصاص دادیم و گفتیم از کجا نصب کن
helm upgrade nginxapp1 bitnami/ngnix --set service.ports.http=8089   آپدیت پورت وبا سایت موجود 
helm show values bitnami/ngnix   برای مشاهده متغییر های که امکان ویرایش دارند
helm ls لیست هلم های در حال اجرا را نمایش میدهد  

نحوه ایجاد هلم چارت های که خودمان باید ایجاد کنیم

helm create chartstruc1  //ایجاد یک هلم 

bitnami
