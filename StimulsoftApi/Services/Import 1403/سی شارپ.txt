هنگامی که یک کلاس بچه از کلاس پدر ارث بری میکند و کلاس پدر دارای سازنده ورودی هست در کلاس بچه باید از کلمه بیس با ورودی مناسب  ورودی به کلاس پدر ارسال کنیم

pulic class pedar
{
  public pedar(int x)
{
}

}

pulic class child:pedar
{
  public child(int y):base(y)
  {
//base این کلمه به کلاس پدر اشاره میکند
  }

}

//************************************************************
به چه معناست؟
public Guid Id { get; init; }
فقط خواندنی هست و قابل ویرایش نیست مگر فقط داخل همان کلاس بتوانیم مقدار دهی کنیم
و فقط داخل سازنده قابل مقدار دهی هست
public class User
{
    public Guid Id { get; init; }

    // کانستراکتور پیش‌فرض
    public User()
    {
        // اینجا می‌توانیم Id را مقداردهی کنیم
        Id = Guid.NewGuid();
    }

    // کانستراکتور با پارامتر
    public User(Guid customId)
    {
        Id = customId;   // اینجا هم مجاز است
    }
}

//****************************************************************************
در متد استاتیک یک کلاس فقط متوان متد های که از نوع استاتیک هستند صدا زده شود

//****************************************************************************
سازنده کلاس :یک متد هم نام همان کلاس هست که میتوان فیلدهای خصوصی را از طریق این سازنده تکمیل کرد

//*****************************************************************************

overload:وقتی داخل یک کلاس چند تا متد هم نام با ورودی های متفاوت داریم 


//*****************************************************************************

تفاوت موارد زیر را بنویسید
Tolist == قابلیت ویرایش و حذف و خواندن و اضافه کردن را دارد
IEnumerable=فقط خواندنی است

//*****************************************************************************
معماری clean

domain-->Entities--Interfaces
Application-->Business--Cqrs   dependenci-->domain
Infrastructure -->DbContext--Repositorys

//****************************************************************************
public class Test
{
protected int a {get;set;} این متغییر فقط داخل کلاس خودش و فقط داخل کلاسی که از این کلاس تست ارٍث بری کرده است
}
//****************************************************************************
کارایی 
virsual And Override
 برای اینکه بتوانیم تعییراتی در یک متد بدهیم باید ابتدا متد ویرچوال باشد که داخل کلاس دیگر بتوانیم آن را آورراید کنیم
 در اصل بدین صورت است وقتی اورراید میکنیم یعنی بدنه تابع را رایم تغییر می دهیم



//******************************************************************************
خصوصیات کلاس 
abstract
فقط میتوان از آن ارث بری کرد و نمی توان از آن نمونه جدید ایجاد یا پیاده سازی کرد


//*****************************************************************************

خصوصیات کلاس 
sealed
 نمیتوان از آن ارث بری کرد و فقط میتوان از آن نمونه جدید ایجاد یا پیاده سازی کرد




//*****************************************************************************
برای اضافه کردن تمام جدول های خارجی به جدول اصلی
db.users.include(x=>x.lineitems).firstordefault();


//*******************************************************************************
polymorphism چند شکلی یا چند ریختی
به این صورت است که ما یک کلاس اصلی داریم و چند تا کلاس دیگر که از این کلاس اصلی ارث بری میکند و هنگام ساخت از کلاس اصلی میتوان یک نمونه از کلاس های که از کلاس اصلی ارث بری کرده انتخاب نمود

public class animal
{
public virsual void Talk()
{
}

}


public class cat:animal
{
public override void Talk()
{
}

}


public class dog:animal
{
public override void Talk()
{
}

}


animal a=new cat();//upercasting  مجاز است
animal d=new dog();//upercasting  مجاز است


cat a=new animal();//downcasting محاز نیست

//*******************************************************************************************

Dispose
 مدیریت حافظه در سی شارپ باید کلاس مورد نظر از دیسپوز استفاده کند و هنگام استفاده از آن کلاس باید در یوزنیگ باشد

public class person:IDispose 
{


}


useing(person p=new person())//برای مدیریت حافظه حتما باید استفاده شود
{
}

//*********************************************************************************************

generic type
یک نوع می باشد که فعلا نوع ان مشخص نیست و زمان کامپایل نوع داده ای مشخص میشود

public class sum<T>
{

   public sum(T AA)
 {
   console.log(typeof(AA));
 }

}
//******************************************************************************************
برای اینکه متوجه شویم یک متغییر مقدار دارد

int? a =null;
if(a.Hasvalue)
{


}

//*****************************************************************************************

int b=a??0;اگر آ برابر نال بود صفر قرار بده

//**********************************************************************************************
delegate دیلیگیت ها شکل کوچک یک تابع هستند 
در ورودی یک تابه ما میتوانیم انواع داده را تنظیم کنیم حالا برای اینکه بتوانیم یک نوع داده ای داشته باشیم که یک اسم یک متد را به آن ارسال کنیم از دیلیگیت ها استفاده میکنیم
 

public delegate void MyDelegate(int num);


 static void PrintNumber(int number)
    {
        Console.WriteLine("Number: " + number);
    }


 
        MyDelegate del = new MyDelegate(PrintNumber);    
        del(42);//فراخوانی متد





//**************************************************************************************


assembly.load(nameof(projectName));  خواندن اسمبلی های یک پروژه


//*************************************************************************************
Arrow Function Example

1-public int sum(int a,int b)=>a+b;
2-where(x=>x.id==10)

//*************************************************************************************
Delegate   دلیگیت ها

Action<T>   یک نوع تابع می پذیرد که یک ورودی دارد و خروجی ندارد

Action<string> AA=Test1;
AA("ali");


public void Test1(string name)
{
console.write(name);
}

//*****************************************************************************************




